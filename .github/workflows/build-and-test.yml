# Workflow handles both testing and publishing of the gem
# - Tests run on all branches and PRs
# - Publishing only happens on version tags
# - Manual triggers available for debugging
name: build-and-test

on:
  # Trigger on pushes to branches and version tags
  # Note: We combine branch and tag triggers to prevent double-execution
  # when pushing to a branch with an open PR
  push:
    branches: [ "*" ]
    tags: [ "v*" ]
    paths-ignore:
      - 'doc/**'
  # Only trigger specific PR events to avoid redundant runs
  pull_request:
    types: [opened, synchronize, reopened]
    branches: [ "*" ]
    paths-ignore:
      - 'doc/**'
  # Allow manual trigger for debugging and one-off runs
  workflow_dispatch:

# Concurrency settings ensure we don't waste resources on outdated commits
# Each job gets its own group to allow parallel runs of different job types
concurrency:
  group: '${{ github.workflow }}-${{ github.job }}-${{ github.head_ref || github.ref_name }}'
  cancel-in-progress: true

# Global environment variables ensure consistent dependency versions
env:
  BUNDLER_VER: 2.6.1  # Matches production environment
  RUBYGEMS_VER: 3.6.1 # Latest stable version tested

jobs:
  detect-image-change:
    runs-on: ubuntu-latest
    outputs:
      images: ${{ steps.filters.outputs.images }}
      image_matrix: ${{ steps.set-matrix.outputs.matrix }}
    steps:
      - uses: actions/checkout@v3
      
      # Create filters for all images with a single pattern
      - name: filter for ci image changes
        id: filters
        uses: dorny/paths-filter@v3
        with:
          list-files: 'json'
          filters: |
            images:
              - 'images/ci/**'
              - '.github/workflows/build-and-test.yml'
      
      # Set matrix based on affected image directories
      - name: set matrix
        id: set-matrix
        if: steps.filters.outputs.images == 'true'
        run: |
          # Start with empty array
          MATRIX="[]"
    
          # Get list of affected files
          FILES='${{ steps.filters.outputs.images_files }}'
    
          # Check each directory under images/ci
          for DIR in $(find images/ci -maxdepth 1 -mindepth 1 -type d -exec basename {} \;); do
            echo "looking at directory $DIR..."

            echo "  FILES = <$FILES>"

            # Check if any file path starts with this directory path
            if echo "$FILES" | jq -e --arg dir "$DIR" 'map(select(startswith("images/ci/" + $dir + "/"))) | length > 0' >/dev/null; then
              echo "change detected in image dir $DIR"
              MATRIX=$(echo "$MATRIX" | jq --arg dir "$DIR" '. += [$dir]')
            else
              echo "no changes detected in $DIR"
            fi
          done
    
          # If workflow file changed but no specific image dir, include all image dirs
          if [[ $(echo "$FILES" | jq 'map(select(. == ".github/workflows/build-and-test.yml")) | length') -gt 0 && $(echo "$MATRIX" | jq 'length') -eq 0 ]]; then
            for DIR in $(find images/ci -maxdepth 1 -mindepth 1 -type d -exec basename {} \;); do
              MATRIX=$(echo "$MATRIX" | jq --arg dir "$DIR" '. += [$dir]')
            done
          fi

          echo "Final matrix before compacting: $MATRIX"

          # Ensure matrix is a valid JSON array and compact it to a single line
          if ! echo "$MATRIX" | jq empty; then
            echo "Invalid JSON, setting empty array"
            MATRIX="[]"
          else
            # Compact JSON to a single line with no extra spaces
            MATRIX=$(echo "$MATRIX" | jq -c '.')
            echo "Compacted matrix: $MATRIX"
          fi
    
          # Ensure MATRIX is valid JSON with no newlines
          echo "matrix=$MATRIX" >> $GITHUB_OUTPUT

  build-nongha-images:
    needs: detect-image-change
    if: ${{ needs.detect-image-change.outputs.images == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    strategy:
      matrix:
        image: ${{ fromJson(needs.detect-image-change.outputs.image_matrix) }}
    
    steps:
      - uses: actions/checkout@v3
      
      - name: login to ghcr
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      # Determine branch name
      - name: Set branch environment variables
        id: branch_env
        run: |
          BRANCH_NAME=${{ github.head_ref || github.ref_name }}
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "is_master=${{ github.ref == 'refs/heads/master' }}" >> $GITHUB_OUTPUT
          
      - name: build and push ${{ matrix.image }} image
        uses: docker/build-push-action@v4
        with:
          context: ./images/ci/${{ matrix.image }}
          push: true
          tags: |
            ${{ steps.branch_env.outputs.is_master == 'true' && format('ghcr.io/{0}/fig-ci:{1}', github.repository, matrix.image) || '' }}
            ghcr.io/${{ github.repository }}/fig-ci:${{ matrix.image }}-${{ steps.branch_env.outputs.branch_name }}


  # Package job: Build and verify the gem
  # We only need to package once since this is a pure Ruby gem
  # Running on latest Ubuntu for consistent builds
  package:
    runs-on: ubuntu-latest
    strategy:
      matrix:
        ruby:
          - "3.1.2"  # Build with minimum supported Ruby version for widest compatibility

    steps:
      - uses: actions/checkout@v3

      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ matrix.ruby }}

      - run: gem update --system $RUBYGEMS_VER

      - name: Install gem dependencies
        env:
          CC: false
          LD: false
          CXX: false
        run: bundle install

      - name: Build gem
        run: bundle exec rake gem

      - name: Run tests
        env:
          FIG_SVN_EXECUTABLE: 
        run: bundle exec rake rspec

      - name: Upload gem
        uses: actions/upload-artifact@v4
        with:
          name: fig
          path: pkg/fig-*.gem

  verify-version:
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Verify version matches tag
        run: |
          # Extract version from version.rb
          EMBEDDED_VERSION=$(grep -o "VERSION = '.*'" lib/fig/version.rb | cut -d"'" -f2)
          # Extract version from git tag (remove 'v' prefix)
          TAG_VERSION=${GITHUB_REF#refs/tags/v}
          
          echo "Version in version.rb: $EMBEDDED_VERSION"
          echo "Version from git tag: $TAG_VERSION"
          
          if [ "$EMBEDDED_VERSION" != "$TAG_VERSION" ]; then
            echo "::error::Version mismatch! version.rb ($EMBEDDED_VERSION) does not match git tag ($TAG_VERSION)"
            exit 1
          fi

  publish:
    needs: [package, verify-version]
    if: startsWith(github.ref, 'refs/tags/v')
    runs-on: ubuntu-latest
    permissions:
      contents: write  # needed for creating releases
      packages: write
    environment:
      name: rubygems
      url: https://rubygems.org/gems/fig

    steps:
      - uses: actions/checkout@v4

      - name: Download gem artifact
        uses: actions/download-artifact@v4
        with:
          name: fig
          path: pkg/

      - name: Get gem version
        id: gem-version
        run: |
          GEM_VERSION=$(ls pkg/*.gem | sed 's/.*-\([0-9.]\+\)\.gem/\1/')
          echo "version=${GEM_VERSION}" >> "$GITHUB_OUTPUT"

      - name: Create Release
        uses: softprops/action-gh-release@v2
        with:
          files: pkg/*.gem
          name: Release v${{ steps.gem-version.outputs.version }}
          draft: false
          prerelease: false
          generate_release_notes: true

      - name: Set up Ruby
        uses: ruby/setup-ruby@v1
        with:
          ruby-version: '3.3.7'
          bundler: '2.6.1'
          rubygems: '3.6.1'

      - name: Publish to RubyGems
        env:
          # Using environment secrets for better security
          RUBYGEMS_API_KEY: ${{ secrets.RUBYGEMS_API_KEY }}
        run: |
          mkdir -p $HOME/.gem
          echo -e "---\n:rubygems_api_key: ${RUBYGEMS_API_KEY}" > $HOME/.gem/credentials
          chmod 0600 $HOME/.gem/credentials
          gem push pkg/*.gem
          rm -f $HOME/.gem/credentials

  compute-tag:
    runs-on: ubuntu-latest
    outputs:
      BRANCH_NAME: ${{ steps.branch_env.outputs.branch_name }}
    steps:
      - name: Set branch environment variables
        id: branch_env
        run: |
          BRANCH_NAME=${{ github.head_ref || github.ref_name }}
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
          echo "is_master=${{ github.ref == 'refs/heads/master' }}" >> $GITHUB_OUTPUT

  whats-my-tag:
    needs: compute-tag
    runs-on: ubuntu-latest
    steps:
      - name: 
        run: |
          echo "branch name=${{ needs.compute-tag.outputs.BRANCH_NAME }}"
          echo "image=${{ format('ghcr.io/{0}/fig-ci:centos7.9.2009-{1}', github.repository, needs.compute-tag.outputs.BRANCH_NAME) }}"
          
# Need to figure out how to parameterize the common parts of
# these jobs and factor out only the differing parts.
  test-gem-install-nongha:
    # Enable the job
    needs: [ package, compute-tag ]
    runs-on: ubuntu-latest
    strategy:
      fail-fast: false  # Don't fail the entire matrix if one job fails
      matrix:
        # This would list all available image directories
        image:
          - centos7.9.2009
          - rocky8
          - ubuntu20.04
        ruby-version:
          - "3.1.2"
          - "3.3.7"
    container:
      # Use stable tag on master, branch-based tag on feature branches
      image: ${{ github.ref == 'refs/heads/master' && format('ghcr.io/{0}/fig-ci:{1}', github.repository, matrix.image) || format('ghcr.io/{0}/fig-ci:{1}-{2}', github.repository, matrix.image, needs.compute-tag.outputs.BRANCH_NAME) }}
      options: --user root

    steps:
      # GitHub CLI is now pre-installed in the Docker images
      - name: Authenticate GH CLI
        run: echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token

      # Download the artifact
      - name: Download with gh cli
        run: |
          # find the last run's artifacts for this workflow & job
          gh run download $GITHUB_RUN_ID --repo ${{ github.repository }} --name fig --dir ./

      - name: Install and test gem with specific Ruby version
        run: |
          # Switch to the specified Ruby version using asdf
          asdf set -u ruby ${{ matrix.ruby-version }}
          
          # Verify Ruby version
          ruby --version
          
          # Install and verify gem
          gem install ./fig-*.gem --platform ruby --no-document
          fig --version
          
          # Basic smoke test
          fig help

  test-gem-install-gha:
    needs: package
    runs-on: ubuntu-latest
    container:
      image: ${{ matrix.os }}
    strategy:
      matrix:
        os:
          - ubuntu:22.04
          - ubuntu:24.04
        ruby:
          - "3.1.2"
          - "3.3.7"
    steps:
      - name: Install packages required by github actions and ruby itself
        # ensure apt-get doesn't stop to ask questions
        if: ${{ contains(matrix.os, 'ubuntu') }}
        env:
          DEBIAN_FRONTEND: noninteractive
        run: |
          apt-get update
          apt-get install -y libyaml-0-2 openssl nodejs build-essential

      - name: Download gem
        uses: actions/download-artifact@v4
        with:
          name: fig
          path: .

      - uses: ruby/setup-ruby@v1
        with:
          ruby-version: ${{ matrix.ruby }}

      - run: |
          gem update --system $RUBYGEMS_VER
          gem install ./fig-*.gem --no-document
